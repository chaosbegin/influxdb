syntax = "proto3";

package influxdb3.internal.node_data_management.v1;

// For ShardId, NodeId - these are represented as u64 in this proto
// corresponding to their Rust struct definitions.

message ShardIdentifier {
    string db_name = 1;
    string table_name = 2;
    uint64 shard_id = 3;
}

// Prepare Shard Snapshot (on source node)
message PrepareShardSnapshotRequest {
    ShardIdentifier shard_identifier = 1;
    // string snapshot_id = 2; // Optional: ID for this snapshot operation, could be generated by coordinator
}
message PrepareShardSnapshotResponse {
    bool success = 1;
    string error_message = 2; // Empty if success is true
    // string snapshot_path_on_object_store = 3; // Optional: Location if snapshot is stored centrally
}

// Apply Shard Snapshot (on target node)
message ApplyShardSnapshotRequest {
    ShardIdentifier shard_identifier = 1;
    // string snapshot_path_on_object_store = 2; // Optional: Location if snapshot is stored centrally
}
message ApplyShardSnapshotResponse {
    bool success = 1;
    string error_message = 2; // Empty if success is true
}

// Signal WAL Stream Processed (target signals it has processed streamed WAL up to a consistent point)
message SignalWalStreamProcessedRequest {
    ShardIdentifier shard_identifier = 1;
    // uint64 last_wal_sequence_processed = 2; // Optional: specific sequence for more advanced sync
}
message SignalWalStreamProcessedResponse {
    bool success = 1;
    string error_message = 2; // Empty if success is true
}

// Lock Shard Writes (on source or target during cutover)
message LockShardWritesRequest {
    ShardIdentifier shard_identifier = 1;
}
message LockShardWritesResponse {
    bool success = 1;
    string error_message = 2; // Empty if success is true
}

// Unlock Shard Writes (on target after cutover)
message UnlockShardWritesRequest {
    ShardIdentifier shard_identifier = 1;
}
message UnlockShardWritesResponse {
    bool success = 1;
    string error_message = 2; // Empty if success is true
}

// Delete Shard Data (on source node after migration)
message DeleteShardDataRequest {
    ShardIdentifier shard_identifier = 1;
}
message DeleteShardDataResponse {
    bool success = 1;
    string error_message = 2; // Empty if success is true
}

service NodeDataManagementService {
    // Called on source node to prepare (e.g., create and possibly upload) a snapshot of a shard.
    rpc PrepareShardSnapshot(PrepareShardSnapshotRequest) returns (PrepareShardSnapshotResponse);

    // Called on target node to apply a snapshot (e.g., download from object store and load).
    rpc ApplyShardSnapshot(ApplyShardSnapshotRequest) returns (ApplyShardSnapshotResponse);

    // Conceptual: Target signals it has processed streamed WAL and is ready for cutover.
    rpc SignalWalStreamProcessed(SignalWalStreamProcessedRequest) returns (SignalWalStreamProcessedResponse);

    // Called on source (primarily) and potentially target node to temporarily block writes to a shard during cutover.
    rpc LockShardWrites(LockShardWritesRequest) returns (LockShardWritesResponse);

    // Called on target node (primarily) to allow writes after a successful cutover.
    rpc UnlockShardWrites(UnlockShardWritesRequest) returns (UnlockShardWritesResponse);

    // Called on source node to delete local data for a shard after it has been successfully migrated.
    rpc DeleteShardData(DeleteShardDataRequest) returns (DeleteShardDataResponse);
}
